<!-- build time:Tue Aug 27 2024 14:55:51 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CYX" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="CYX" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="CYX" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Spring Cloud"><link rel="canonical" href="http://example.com/2024/06/27/post/cloud/%E5%88%86%E5%B8%83%E5%BC%8FSpringCloud%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"><title>分布式Spring Cloud阿里巴巴-理论 - 微服务框架 | ZoroJan-个人博客 = CYX = Blog</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">分布式Spring Cloud阿里巴巴-理论</h1><div class="meta"><span class="item" title="创建时间：2024-06-27 17:42:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-06-27T17:42:00+08:00">2024-06-27</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>26k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>24 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">ZoroJan-个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/10.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cloud/" itemprop="item" rel="index" title="分类于 微服务框架"><span itemprop="name">微服务框架</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/06/27/post/cloud/%E5%88%86%E5%B8%83%E5%BC%8FSpringCloud%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="ZoroJan"><meta itemprop="description" content="Blog, 我的个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CYX"></span><div class="body md" itemprop="articleBody"><h1 id="分布式spring-cloud阿里巴巴">分布式Spring Cloud阿里巴巴</h1><p>（图片还未上传云）</p><h1 id="spring-cloud">---01-Spring Cloud</h1><h2 id="一微服务架构">一、微服务架构</h2><h4 id="什么是微服务架构">1、什么是微服务架构</h4><p>分布式强调系统的拆分，微服务也是强调系统的拆分，微服务架构属于分布式架构的范畴；</p><p>并且到目前为止，微服务并没有一个统一的标准的定义，那么微服务究竟是什么？</p><p>微服务一词源于Martin Fowler（马丁.福勒）的名为 Microservices 的博文， 可以在他的官方博客上找到这篇文章： http://martinfowler.com/articles/microservices.html</p><p>中文翻译版本：</p><p>https://www.martinfowler.cn/articles/microservices.html</p><p>简单地说， 微服务是系统架构上的一种设计风格， 它的主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP的RESTful API进行通信协作；</p><p>被拆分后的每一个小型服务都围绕着系统中的某一项业务功能进行构建， 并且每个服务都是一个独立的项目，可以进行独立的测试、开发和部署等；</p><p>由于各个独立的服务之间使用的是基于HTTP的作为数据通信协作的基础，所以这些微服务可以使用不同的语言来开发；</p><h4 id="微服务架构的优缺点">2、微服务架构的优缺点</h4><p>优：</p><ol type="1"><li>微服务架构是将系统中的不同功能模块拆分成多个不同的服务，这些服务进行独立地开发和部署，每个服务都运行在自己的进程内，这样每个服务的更新都不会影响其他服务的运行；</li><li>由于每个服务是独立部署的，所以我们可以更准确地监控每个服务的资源消耗情况，进行性能容量的评估，通过压力测试，也很容易发现各个服务间的性能瓶颈所在；</li><li>由于每个服务都是独立开发，项目的开发也比较方便，减少代码的冲突、代码的重复，逻辑处理流程也更加清晰，让后续的维护与扩展更加容易；</li><li>微服务可以使用不同的编程语言进行开发；</li></ol><p>缺：</p><ol type="1"><li><p>微服务架构增加了系统维护、部署的难度，导致一些功能模块或代码无法复用；</p></li><li><p>随着系统规模的日渐增长，微服务在一定程度上也会导致系统变得越来越复杂，增加了集成测试的复杂度；</p></li><li><p>随着微服务的增多，数据的一致性问题，服务之间的通信成本等都凸显了出来；</p><p>所以在系统架构时也要提醒自己：不要为了微服务而微服务</p></li></ol><h4 id="为什么选择spring-cloud-来构建微服务">3、为什么选择Spring Cloud 来构建微服务</h4><p>我们国内的互联网企业也有一些著名的框架和方案；</p><p>整个微服务架构是由大量的技术框架和方案构成，比如：</p><table><colgroup><col style="width:18%"><col style="width:81%"></colgroup><thead><tr><th>服务基础开发</th><th>Spring MVC、Spring、SpringBoot</th></tr></thead><tbody><tr><td>服务注册与发现</td><td>Netflix的Eureka、Apache的ZooKeeper等</td></tr><tr><td>服务调用</td><td>RPC调用有阿里巴巴的Dubbo，Rest方式调用有当当网Dubbo基础上扩展的Dubbox、还有其他方式实现的Rest，比如Ribbon、Feign</td></tr><tr><td>分布式配置管理</td><td>百度的Disconf、360的QConf、淘宝的Diamond、Netflix的Archaius等</td></tr><tr><td>负载均衡</td><td>Ribbon</td></tr><tr><td>服务熔断</td><td>Hystrix</td></tr><tr><td>API网关</td><td>Zuul</td></tr><tr><td>批量任务</td><td>当当网的Elastic-Job、Linkedln的Azkaban</td></tr><tr><td>服务跟踪</td><td>京东的Hydra、Twitter的Zipkin等</td></tr></tbody></table><h3 id="二spring-cloud">二、Spring Cloud</h3><p>官网：http://spring.io</p><h4 id="spring-cloud是什么">1、Spring Cloud是什么</h4><ol type="1"><li>Spring Cloud是一个一站式的开发分布式系统的框架，为开发者提供了一系列的构建分布式系统的工具集；</li><li>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（比如：配置管理，服务发现，断路器，智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等）；</li><li>开发分布式系统都需要解决一系列共同关心的问题，而使用Spring Cloud可以快速地实现这些分布式开发共同关心的问题，并能方便地在任何分布式环境中部署与运行。</li><li>Spring Cloud这个一站式地分布式开发框架，被近年来流行的“微服务”架构所大力推崇，成为目前进行微服务架构的优先选择工具；</li><li>Spring Cloud基于Spring Boot框架构建微服务架构，学习Spring Cloud需要先学习Spring Boot；</li></ol><h4 id="整体框架">2、整体框架</h4><figure><img data-src="D:\Pictures\typore\image-20240507092722104.png" alt="image-20240507092722104"><figcaption aria-hidden="true">image-20240507092722104</figcaption></figure><p>Service Provider： 暴露服务的服务提供方。</p><p>Service Consumer：调用远程服务的服务消费方。</p><p>EureKa Server： 服务注册中心和服务发现中心。</p><h3 id="三服务注册中心eureka">三、服务注册中心Eureka</h3><h4 id="走进服务中心eureka">1、走进服务中心Eureka</h4><p>在微服务架构中，<strong>服务注册与发现是核心组件之一</strong>，手动指定每个服务是很低效的，Spring Cloud提供了多种服务注册与发现的实现方式，例如：Eureka、Zookeeper。</p><p>Spring Cloud支持得最好的是Eureka，其次是Zookeeper。</p><p>1、什么是服务注册</p><p>服务注册：将服务所在主机、端口、版本号、通信协议等信息登记到注册中心上。</p><p>2、什么是服务发现</p><p>服务发现：服务消费者向注册中心请求已经登记的服务列表，然后得到某个服务的主机、端口、版本号、通信协议等信息，从而实现对具体服务的调用。</p><p>3、Eureka是什么</p><p>Eureka是一个服务治理组件，它主要包括服务注册和服务发现，主要用来搭建服务注册中心。</p><p>Eureka 是一个基于 REST 的服务，用来定位服务，进行中间层服务器的负载均衡和故障转移；</p><p>Eureka 采用了C-S（客户端/服务端）的设计架构，也就是Eureka由两个组件组成：Eureka服务端和Eureka客户端。Eureka Server 作为服务注册的服务端，它是服务注册中心，而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server服务端，并维持心跳连接，Eureka客户端是一个Java客户端，用来简化与服务器的交互、负载均衡，服务的故障切换等；</p><p>有了Eureka注册中心，系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p><h4 id="eureka与zookeeper的比较">2、Eureka与Zookeeper的比较</h4><p>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。</p><p>由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡，在此Zookeeper保证的是CP, 而Eureka则是AP。</p><p><strong>1、Zookeeper保证CP</strong></p><p>在ZooKeeper中，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是问题在于，选举leader需要一定时间, 且选举期间整个ZooKeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得ZooKeeper集群失去master节点是大概率事件，虽然服务最终能够恢复，但是在选举时间内导致服务注册长期不可用是难以容忍的。</p><p><strong>2、Eureka保证AP</strong></p><p>Eureka优先保证可用性，Eureka各个节点是平等的，某几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p><p>所以Eureka在网络故障导致部分节点失去联系的情况下，只要有一个节点可用，那么注册和查询服务就可以正常使用，而不会像zookeeper那样使整个注册服务瘫痪，Eureka优先保证了可用性。</p><h3 id="四客户端负载均衡ribbon">四、客户端负载均衡Ribbon</h3><h4 id="负载均衡">1、负载均衡</h4><p>负载均衡：<strong>指将一个请求均匀地分摊到不同的节点单元上执行，负载均和分为硬件负载均衡和软件负载均衡</strong>：</p><p><strong>硬件负载均衡</strong>：比如 F5、深信服、Array 等</p><p><strong>软件负载均衡</strong>：比如 Nginx、LVS、HAProxy 等</p><p>硬件负载均衡或是软件负载均衡，他们都会维护一个可用的服务端清单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均衡设备的时候，该设备按某种算法（比如轮询、权重、 最小连接数等）从维护的可用服务端清单中取出一台服务端的地址，然后进行转发。</p><h4 id="ribbon介绍">2、Ribbon介绍</h4><p>Ribbon是Netflix发布的开源项目，<strong>主要功能</strong>是<u>提供客户端的软件负载均衡算法，是一个基于HTTP和TCP的客户端负载均衡工具</u>。</p><p>Spring Cloud对Ribbon做了二次封装，可以让我们使用<strong>RestTemplate</strong>的服务请求，自动转换成客户端负载均衡的服务调用。</p><p>Ribbon支持多种负载均衡算法，还支持自定义的负载均衡算法。</p><p>Ribbon只是一个工具类框架，比较小巧，Spring Cloud对它封装后使用也非常方便，它不像服务注册中心、配置中心、API网关那样需要独立部署，<strong>Ribbon只需要在代码直接使用即可</strong>；</p><h4 id="ribbon-与-nginx-的区别">3、Ribbon 与 Nginx 的区别</h4><p>Ribbon是客户端的负载均衡工具，而客户端负载均衡和服务端负载均衡最大的区别在于服务清单所存储的位置不同，在客户端负载均衡中，所有客户端节点下的服务端清单，需要自己从服务注册中心上获取，比如Eureka服务注册中心。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。在Spring Cloud中，由于Spring Cloud对Ribbon做了二次封装，所以默认会创建针对Ribbon的自动化整合配置</p><h4 id="使用">4、使用</h4><p>在Spring Cloud中，Ribbon主要与RestTemplate对象配合起来使用，Ribbon会自动化配置RestTemplate对象，通过@LoadBalanced开启RestTemplate对象调用时的负载均衡。</p><figure><img data-src="D:\Pictures\typore\image-20240507093858824.png" alt="image-20240507093858824"><figcaption aria-hidden="true">image-20240507093858824</figcaption></figure><h3 id="五resttemplate模板">五、RestTemplate模板</h3><p>当我们从服务消费端去调用服务提供者的服务的时候，使用了一个极其方便的对象叫RestTemplate，当时我们只使用了RestTemplate中最简单的一个功能getForEntity发起了一个get请求去调用服务端的数据，同时，我们还通过配置@LoadBalanced注解开启客户端负载均衡，RestTemplate的功能非常强大，那么接下来我们就来详细的看一下RestTemplate中几种常见请求方法的使用。</p><p>在日常操作中，基于Rest的方式通常是四种情况，它们分表是：</p><p><strong>GET请求 --查询数据</strong></p><p><strong>POST请求 –添加数据</strong></p><p><strong>PUT请求 – 修改数据</strong></p><p><strong>DELETE请求 –删除数据</strong></p><p>下面我们逐一解读。</p><h3 id="六服务熔断hystrix">六、服务熔断Hystrix</h3><h4 id="hystrix是什么">1、Hystrix是什么</h4><p>​ 在微服务架构中，我们是将一个<strong>单体应用拆分成多个服务单元</strong>，各个服务单元之间通过注册中心彼此发现和消费对方提供的服务，每个服务单元都是单独部署，在各自的服务进程中运行，服务之间通过远程调用实现信息交互，那么当某个服务的响应太慢或者故障，又或者因为网络波动或故障，则会造成调用者延迟或调用失败，当大量请求到达，则会造成请求的堆积，导致调用者的线程挂起，从而引发调用者也无法响应，调用者也发生故障。</p><p>EG：电商中的用户下订单，我们有两个服务，一个下订单服务，一个减库存服务，当用户下订单时调用下订单服务，然后下订单服务又调用减库存服务，如果减库存服务响应延迟或者没有响应，则会造成下订单服务的线程挂起等待，如果大量的用户请求下订单，或导致大量的请求堆积，引起下订单服务也不可用，如果还有另外一个服务依赖于订单服务，比如用户服务，它需要查询用户订单，那么用户服务查询订单也会引起大量的延迟和请求堆积，导致用户服务也不可用。</p><p>所以在微服务架构中，很容易造成服务故障的蔓延，引发整个微服务系统瘫痪不可用。为了解决此问题，微服务架构中引入了一种叫熔断器的服务保护机制。</p><p>微服务架构中的熔断器，就是<strong>当被调用方没有响应，调用方直接返回一个错误响应即可，而不是长时间的等待</strong>，这样避免调用时因为等待而线程一直得不到释放，避免故障在分布式系统间蔓延；</p><p>用法：</p><ol type="1"><li>异常熔断</li><li>超时熔断</li><li>Hystrix的服务降级</li><li>Hystrix的异常处理</li><li>异常忽略</li><li>自定义熔断处理</li></ol><p>3.Hystrix的服务降级</p><p>有了服务的熔断，随之就会有服务的降级，所谓服务降级，就是当某个服务熔断之后，服务端提供的服务将不再被调用，此时由客户端自己准备一个本地的fallback回调，返回一个默认值来代表服务端的返回；</p><p>这种做法，虽然不能得到正确的返回结果，但至少保证了服务的可用，比直接抛出错误或服务不可用要好很多，当然这需要根据具体的业务场景来选择；</p><p>6.自定义熔断处理</p><p>我们也可以自定义类继承自HystrixCommand来实现自定义的Hystrix请求，在getFallback方法中调用getExecutionException方法来获取服务抛出的异常，这种熔断主要针对于远程服务的异常处理。</p><h3 id="七声明式服务消费feign">七、声明式服务消费Feign</h3><h4 id="fegin介绍">1、Fegin介绍</h4><p>Feign是Netflix公司开发的一个声明式的<strong>REST调用客户端</strong>；</p><p>Ribbon负载均衡、Hystrix服务熔断是我们Spring Cloud中进行微服务开发非常基础的组件，在使用的过程中我们也发现它们一般都是同时出现的，而且配置也都非常相似，每次开发都有很多相同的代码，<strong>因此Spring Cloud基于Netflix Feign整合了Ribbon和Hystrix两个组件</strong>，让我们的开发工作变得更加简单，就像Spring Boot是对Spring+SpringMVC的简化一样，Spring Cloud Feign对Ribbon负载均衡、Hystrix服务熔断进行简化，在其基础上进行了进一步的封装，不仅在配置上大大简化了开发工作，同时还提供了一种声明式的Web服务客户端定义方式；</p><h1 id="nacos">----02-Nacos</h1><h3 id="一springcloudalibab简介">一、springCloudAlibab简介</h3><p>Spring Cloud Alibaba 是阿里巴巴提供的微服务开发一站式解决方案，是<strong>阿里巴巴开源中间件与 Spring Cloud 体系的融合</strong>。</p><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>作为 Spring Cloud 体系下的新实现，Spring Cloud Alibaba 跟官方的组件或其它的第三方实现如 Netflix, Consul，Zookeeper 等对比，具备了更多的功能:</p><figure><img data-src="D:\Pictures\typore\image-20240507094612394.png" alt="image-20240507094612394"><figcaption aria-hidden="true">image-20240507094612394</figcaption></figure><p>https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html</p><h3 id="二nacos">二、Nacos</h3><h4 id="什么是nacos">1、什么是nacos</h4><p>https://nacos.io/zh-cn/docs/what-is-nacos.html</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><h4 id="使用-1">2、使用</h4><ol type="1"><li>Nacos下载和安装</li><li>服务注册和发现</li><li>分布式配置中心</li><li>数据持久化<ol type="1"><li>配置数据源（数据库-表）</li></ol></li><li>Nacos集群配置</li></ol><h1 id="sentinel">----03-Sentinel</h1><h3 id="一sentinel">一、Sentinel</h3><h4 id="sentinel是什么">1、Sentinel是什么</h4><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。</p><p>Sentinel :以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>主要特征：</p><ol type="1"><li><strong>丰富的应用场景</strong></li><li><strong>完备的实时监控</strong></li><li><strong>广泛的开源生态</strong></li><li><strong>完善的 SPI 扩展机制</strong></li></ol><p>主要特性：</p><figure><img data-src="D:\Pictures\typore\image-20240507095123148.png" alt="image-20240507095123148"><figcaption aria-hidden="true">image-20240507095123148</figcaption></figure><h4 id="主要功能">2、主要功能</h4><p>1、流量控制</p><p>​ <strong>流量控制</strong>（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p>2、熔断降级</p><p>​ 除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><p>3、热点参数限流</p><p>​ 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><p>4、黑白名单控制</p><p>​ 很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制（黑白名单控制）的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p><p>5、系统自适应限流</p><p>​ 系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><h1 id="gateway">---04-GateWay</h1><h3 id="一认识gateway">一、认识GateWay</h3><h4 id="spring-cloud的gateway">1、 Spring Cloud的Gateway</h4><p>1、Spring Cloud的Gateway是什么</p><p>首先来看一个微服务架构图：</p><figure><img data-src="D:\Pictures\typore\image-20240507095522777.png" alt="image-20240507095522777"><figcaption aria-hidden="true">image-20240507095522777</figcaption></figure><p>在上面的架构图中，我们的服务包括：内部服务Service A和内部服务Service B，这两个服务都是集群部署，每个服务部署了3个实例，他们都会通过Eureka Server注册中心注册与订阅服务，而Open Service是一个对外的服务，也是集群部署，外部调用方通过负载均衡设备调用Open Service服务，比如负载均衡使用Nginx，这样的实现是否合理，或者是否有更好的实现方式呢？接下来我们主要围绕该问题展开讨论。</p><p>1、如果我们的微服务中有很多个独立服务都要对外提供服务，那么我们要如何去管理这些接口？特别是当项目非常庞大的情况下要如何管理？</p><p>2、在微服务中，一个独立的系统被拆分成了很多个独立的服务，为了确保安全，权限管理也是一个不可回避的问题，如果在每一个服务上都添加上相同的权限验证代码来确保系统不被非法访问，那么工作量也就太大了，而且维护也非常不方便。</p><p>为了解决上述问题，微服务架构中提出了API网关的概念，它就像一个安检站一样，所有外部的请求都需要经过它的调度与过滤，然后API网关来实现请求路由、负载均衡、权限验证等功能；</p><p>那么Spring Cloud这个一站式的微服务开发框架基于Netflix Zuul实现了Spring Cloud Zuul，采用Spring Cloud Zuul即可实现一套API网关服务。</p><p>2、Spring Cloud Gateway简介</p><p><strong>你们项目里面 用的什么网关？ gateway zuul</strong></p><p>它是Spring Cloud<strong>官方</strong>提供的用来取代<strong>zuul（netflix）</strong>的新一代网关组件</p><p>（zuul：1.0 , 2.0 ，zuul的本质，<strong>一组过滤器，根据自定义的过滤器顺序来执行，本质就是web组件</strong>）</p><p>Zuul1.0 使用的是BIO（Blocking IO） tomcat7.0以前都是BIO 性能一般</p><p>Zuul2.0 性能好NIO</p><p>它基于spring5.x，springboot2.x和ProjectReactor等技术。</p><p>它的目地是让<strong>路由更加简单，灵活，还提供了一些强大的过滤器功能</strong>，例如：熔断、限流、重试,自义定过滤器等 token校验ip黑名单等</p><p>SpringCloud Gateway作为Spring Cloud生态的网关，目标是替代Zuul，在SpringCloud2.0以上的版本中，没有对新版本的zuul2.0以上的最新高性能版本进行集成，仍然还是使用的zuul1.x[可以看项目依赖找到]非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于webFlux 框架实现的，而webFlux框架底层则使用了高性能的Reactor模式通信框架的Netty</p><p>NIO(非阻塞式io) BIO 你只需要了解网关能做什么？ 网关里面写什么代码 就可以了</p><figure><img data-src="D:\Pictures\typore\image-20240507095601997.png" alt="image-20240507095601997"><figcaption aria-hidden="true">image-20240507095601997</figcaption></figure><p>3、工作流程</p><figure><img data-src="D:\Pictures\typore\image-20240507095704824.png" alt="image-20240507095704824"><figcaption aria-hidden="true">image-20240507095704824</figcaption></figure><p>客户端向springcloud Gateway 发出请求</p><p>然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。</p><p>Handler 再通过指定的过滤器来将请求发送到我们实际的服务的业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送请求之前【pre】或之后【post】执行业务逻辑，对其进行加强或处理。</p><p>Filter在 【pre】 类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等</p><p>在【post】 类型的过滤器中可以做响应内容、响应头的修改、日志的输出，流量监控等有着非常重要的作用。</p><p><strong>总结：Gateway 的核心逻辑也就是 路由转发 + 执行过滤器链</strong></p><p>4、三大核心概念</p><p><strong>Route（路由）</strong></p><p>路由信息的组成：</p><p>由一个ID、一个目的URL、一组断言工厂、一组Filter组成。</p><p>如果路由断言为真，说明请求URL和配置路由匹配。</p><p><strong>Predicate（断言）</strong></p><p>Java 8中的断言函数。 lambda 四大接口 供给形，消费性，函数型，断言型</p><p>Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway的断言函数允许开发者去定义匹配来自于Http Request中的任何信息比如请求头和参数。</p><p><strong>Filter（过滤）</strong></p><p>一个标准的Spring WebFilter。 Web三大组件(servlet listener filter) mvc interceptor</p><p>Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。</p><p>一个是针对某一个路由的filter 对某一个接口做限流</p><p>一个是针对全局的filter token ip黑名单</p><h1 id="rocketmq">---05-RocketMQ</h1><h3 id="一rocketmq概述">一、RocketMQ概述</h3><h4 id="什么是消息队列">1、什么是消息队列</h4><h4 id="为什么要使用消息队列">2、为什么要使用消息队列</h4><h4 id="rocketmq基本概念16条">3、RocketMQ基本概念（16条）</h4><ol type="1"><li><p>消息模型（Message Model）</p><p>​ RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p></li><li><p>消息生产者（Producer）</p><p>​ 负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p></li><li><p>消息消费者（Consumer）</p><p>​ 负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p></li><li><p>主题（Topic）</p><p>​ 表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p></li><li><p>代理服务器（Broker Server）</p><p>​ 消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p></li><li><p>名字服务（Name Server）</p><p>​ 名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p></li><li><p>拉取式消费（Pull Consumer）</p><p>​ Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p></li><li><p>推动式消费（Push Consumer）</p><p>​ Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p></li><li><p>生产者组（Producer Group）</p><p>​ 同一类Producer的集合，这类Producer发送<strong>同一类消息且发送逻辑一致</strong>。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p></li><li><p>消费者组（Consumer Group）</p><p>​ 同一类Consumer的集合，这类Consumer通常<strong>消费同一类消息且消费逻辑一致</strong>。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的Topic</strong>。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p></li><li><p>集群消费（Clustering）</p><p>​ 集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p></li><li><p>广播消费（Broadcasting）</p><p>​ 广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p></li><li><p>普通顺序消息（Normal Ordered Message）</p><p>​ 普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p></li><li><p>严格顺序消息（Strictly Ordered Message）</p><p>​ 严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p></li><li><p>消息（Message）</p><p>​ 消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p></li><li><p>标签（Tag）</p><p>​ 为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p></li></ol><h4 id="rocketmq特性">4、RocketMQ特性</h4><ol type="1"><li><p>订阅与发布</p><p>​ 消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p></li><li><p>消息顺序</p><p>​ 消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p><p>顺序消息分为<strong>全局顺序消息</strong>与<strong>分区顺序消息</strong>，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p><ul><li>全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li><li>分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li></ul></li><li><p>消息过滤</p><p>​ RocketMQ的<strong>消费者可以根据Tag进行消息过滤</strong>，也支持<strong>自定义属性过滤</strong>。消息过滤目前是在Broker端实现的，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p></li><li><p>消息可靠性</p><p>​ RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p><ol type="1"><li>Broker非正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p><p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p></li><li><p>至少一次</p><p>​ 至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p></li><li><p>回溯消费</p><p>​ 回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p></li><li><p>事务消息</p><p>​ RocketMQ事务消息（Transactional Message）是<strong>指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。</strong>RocketMQ的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p></li><li><p>定时消息</p><p>​ 定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。 broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p><ul><li>level == 0，消息为非延迟消息</li><li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li><li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li></ul><p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p><p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p></li><li><p>消息重试</p><p>​ Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ul><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ul><p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p></li><li><p>消息重投</p><p>​ 生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。<strong>消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。</strong>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p><ul><li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li></ul></li><li><p>流量控制</p><p>​ 生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p><p>生产者流控：</p><ul><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li><li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li><li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li><li>broker通过拒绝send 请求方式实现流量控制。</li></ul><p>注意，生产者流控，不会尝试消息重投。</p><p>消费者流控：</p><ul><li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li><li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li><li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li></ul><p>消费者流控的结果是降低拉取频率。</p></li><li><p>死信队列</p><p>​ 死信队列用于<strong>处理无法被正常消费的消息</strong>。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p></li></ol><h1 id="seata">---06-Seata</h1><h3 id="一分布式事务介绍">一、分布式事务介绍</h3><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p><p>例如订单服务添加订单后，需要调用远程商品服务完成减库存操作，这时如何确保添加订单和减少库存的2个SQL要么全部执行要么全部不执行？</p><p>由于2个SQL写操作不在同一事务范围内，因此正常情况无法确保2个事务同时提交或同时回滚，这就会出现数据不一致的现象。这种情况就需要使用分布式事务框来解决这个问题。</p><figure><img data-src="D:\Pictures\typore\image-20240507101415093.png" alt="image-20240507101415093"><figcaption aria-hidden="true">image-20240507101415093</figcaption></figure><h3 id="二seata介绍">二、Seata介绍</h3><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p>官网地址<a target="_blank" rel="noopener" href="https://seata.io/zh-cn">https://seata.io/zh-cn/</a></p><h4 id="相关术语">1、相关术语</h4><p><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者</strong></p><p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p><p><strong>TM (Transaction Manager) -</strong> <strong>事务管理器</strong></p><p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p><p><strong>RM (Resource Manager) -</strong> <strong>资源管理器</strong></p><p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><figure><img data-src="D:\Pictures\typore\image-20240507101504277.png" alt="image-20240507101504277"><figcaption aria-hidden="true">image-20240507101504277</figcaption></figure><h4 id="at模式">2、AT模式</h4><p>1、前提</p><ul><li>基于支持本地 ACID 事务的关系型数据库。</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><p>2、整体机制</p><p>两阶段提交协议：</p><p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p><p>二阶段：</p><ul><li><ul><li>提交异步化，非常快速地完成。</li><li>回滚通过一阶段的回滚日志进行反向补偿。</li></ul></li></ul><p>3、写隔离</p><ul><li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li><li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li><li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li></ul><p>以一个示例来说明：</p><p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p><p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p><figure><img data-src="D:\Pictures\typore\image-20240507101742335.png" alt="image-20240507101742335"><figcaption aria-hidden="true">image-20240507101742335</figcaption></figure><p>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p><figure><img data-src="D:\Pictures\typore\image-20240507101755671.png" alt="image-20240507101755671"><figcaption aria-hidden="true">image-20240507101755671</figcaption></figure><p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p><p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p><p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p><p>4、读隔离</p><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p><p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p><figure><img data-src="D:\Pictures\typore\image-20240507101813112.png" alt="image-20240507101813112"><figcaption aria-hidden="true">image-20240507101813112</figcaption></figure><p>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p><p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p><p>5、工作机制</p><ul><li><p>以一个示例来说明整个 AT 分支的工作过程。</p></li><li><p>业务表：<code>product</code></p></li><li><p>```</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- AT 事务的业务逻辑：</span><br><span class="line"></span><br><span class="line">- update` product `set` `name` = `&#x27;GTS&#x27;` `where` `name` = `&#x27;TXC&#x27;`;`</span><br><span class="line"></span><br><span class="line">- #### 1 一阶段</span><br><span class="line"></span><br><span class="line">- 过程：</span><br><span class="line"></span><br><span class="line">- \1. 解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = &#x27;TXC&#x27;）等相关的信息。</span><br><span class="line"></span><br><span class="line">- \2. 查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</span><br><span class="line"></span><br><span class="line">- select id, name, since from product where name = &#x27;TXC&#x27;;</span><br><span class="line"></span><br><span class="line">- 得到前镜像：</span><br><span class="line"></span><br><span class="line">- `  ```</span><br><span class="line"></span><br><span class="line">- \3. 执行业务 SQL：更新这条记录的 name 为 &#x27;GTS&#x27;。</span><br><span class="line"></span><br><span class="line">- \4. 查询后镜像：根据前镜像的结果，通过 **主键** 定位数据。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  select id, name, since from product where id = 1;</span><br></pre></td></tr></table></figure></li><li><p>\5. 插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</p></li><li><p>`<code>&#123;</code> "branchId": 641789253,<code>"undoItems": [&#123;</code> "afterImage": {<code>"rows": [&#123;</code> "fields": [{<code>"name": "id",</code> "type": 4,<code>"value": 1</code> }, {<code>"name": "name",</code> "type": 12,<code>"value": "GTS"</code> }, {<code>"name": "since",</code> "type": 12,<code>"value": "2014"</code> }]<code>&#125;],</code> "tableName": "product"<code>&#125;,</code> "beforeImage": {<code>"rows": [&#123;</code> "fields": [{<code>"name": "id",</code> "type": 4,<code>"value": 1</code> }, {<code>"name": "name",</code> "type": 12,<code>"value": "TXC"</code> }, {<code>"name": "since",</code> "type": 12,<code>"value": "2014"</code> }]<code>&#125;],</code> "tableName": "product"<code>&#125;,</code> "sqlType": "UPDATE"<code>&#125;],</code> "xid": "xid:xxx"``}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- \6. 提交前，向 TC 注册分支：申请 `product` 表中，主键值等于 1 的记录的 **全局锁** 。</span><br><span class="line"></span><br><span class="line">- \7. 本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</span><br><span class="line"></span><br><span class="line">- \8. 将本地事务提交的结果上报给 TC。</span><br><span class="line"></span><br><span class="line">- #### 2 二阶段-回滚</span><br><span class="line"></span><br><span class="line">- 1. 收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</span><br><span class="line">  2. 通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</span><br><span class="line">  3. 数据校验：拿     UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</span><br><span class="line">  4. 根据 UNDO     LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">          update product set name = &#x27;TXC&#x27; where id = 1;</span><br></pre></td></tr></table></figure><p></p></li><li><ol type="1"><li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC</li></ol></li><li><h4 id="二阶段-提交">3 二阶段-提交</h4></li><li><ol type="1"><li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li></ol></li><li><p>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录</p></li></ul><h4 id="tcc模式">3、TCC模式</h4><p>一个分布式的全局事务，整体是 <strong>两阶段提交</strong> 的模型。全局事务是由若干分支事务组成的，分支事务要满足 <strong>两阶段提交</strong> 的模型要求，即需要每个分支事务都具备自己的：</p><ul><li>一阶段 prepare 行为</li><li>二阶段 commit 或 rollback 行为</li></ul><h4 id="saga模式">4、SAGA模式</h4><p>Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。</p><h4 id="xa模式">5、XA模式</h4><p>前提</p><ul><li>支持XA 事务的数据库。</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><p>整体机制</p><p>在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。</p><h1 id="sky-walking链式跟踪">---07-Sky Walking链式跟踪</h1><h3 id="一sky-walking简介">一、Sky Walking简介</h3><h4 id="主要功能-1">1、主要功能</h4><p>Sky Walking 是针对<strong>分布式系统的APM（应用性能监控）系统</strong>，特别针对微服务、cloud native 和容器化(Docker, Kubernetes, Mesos)架构， 其核心是个<strong>分布式追踪系统</strong>。它通过探针自动收集所需的指标，且<strong>基于探针技术对应用零侵入零耦合</strong>。主要提供以下功能：</p><p>\1. 服务、服务实例和端点(如：单个HTTP URI）的性能指标分析</p><p>\2. 根本原因分析</p><p>\3. 服务拓扑图分析</p><p>\4. 服务和端点依赖分析</p><p>\5. 慢服务和慢端点检测</p><p>\6. 分布式追踪和上下文传播</p><p>\7. 告警</p><h4 id="总体框架">2、总体框架</h4><p>\1. collector：链路数据归集器，数据可以落地MySQL、Elastic Search等</p><p>\2. agent：探针，使用Java agent做字节码植入，无侵入式的收集，并通过HTTP或者g RPC方式发送数据collector</p><p>\3. web ：web可视化平台，用来展示落地的数据</p><h1 id="spring-security">---08-Spring Security</h1><h3 id="一认证授权的基础概念">一、认证授权的基础概念</h3><h4 id="什么是认证登录">1、什么是认证（登录）</h4><p>进入移动互联网时代，大家每天都在刷手机，常用的软件有微信、支付宝、头条等，下边拿微信来举例子说明认证相关的基本概念，在初次使用微信前需要注册成为微信用户，然后输入账号和密码即可登录微信，输入账号和密码登录微信的过程就是认证。</p><p>系统为什么要认证？</p><p>认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源。</p><p>认证 ：<strong>用户认证就是判断一个用户的身份是否合法的过程</strong>，用户去访问系统资源（url接口）时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。</p><p>user.getUserByUsername(“zhangsan”)</p><h4 id="什么是会话">2、什么是会话</h4><p>用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前用户的登录状态所提供的机制，<strong>常见的有基于session方式、基于token方式</strong>等。</p><p>1 基于session的认证方式</p><p>它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了</p><p>2 基于token方式认证方式</p><p>它的交互流程是，用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 local Storage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。Redis 存的用户信息 <strong>共享session</strong> （分布式中）</p><p>基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。<strong>如今移动互联网时代更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合</strong>。</p><h4 id="什么是授权给用户颁发权限">3、什么是授权（给用户颁发权限）</h4><p>还拿微信来举例子，微信登录成功后用户即可使用微信的功能，比如，发红包、发朋友圈、添加好友等，没有绑定银行卡的用户是无法发送红包的，绑定银行卡的用户才可以发红包，发红包功能、发朋友圈功能都是微信的资源即功能资源，用户拥有发红包功能的权限才可以正常使用发送红包功能，拥有发朋友圈功能的权限才可以使用发朋友圈功能，这个根据用户的权限来控制用户使用资源的过程就是授权。 <strong>鉴权（判断用户是否有这个权限）</strong></p><p>java应用中什么叫资源 url就是资源 （接口就是资源）</p><h4 id="授权的数据模型rbac">4、授权的数据模型（RBAC）</h4><p>用户 角色 权限</p><p>如何进行授权即如何对用户访问资源进行控制，首先需要学习授权相关的数据模型。</p><p>授权可简单理解为<strong>Who对What(which)进行How操作</strong>，包括如下：</p><p>Who，即主体（Subject），主体一般是指用户，也可以是程序，需要访问系统中的资源。 What，即资源（Resource），如系统菜单、页面、按钮、代码方法、系统商品信息、系统订单信息等。系统菜单、页面、按钮、代码方法都属于系统功能资源，对于web系统每个功能资源通常对应一个URL；系统商品信息、系统订单信息都属于实体资源（数据资源），实体资源由资源类型和资源实例组成，比如商品信息为资源类型，商品编号 为001的商品为资源实例。 How，权限/许可（Permission），规定了用户对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个代码方法的调用权限、编号为001的用户的修改权限等，通过权限可知用户对哪些资源都有哪些操作可。</p><p>主体、资源、权限关系如下图：</p><figure><img data-src="D:\Pictures\typore\clip_image002-17150487587261.jpg" alt="IMG_256"><figcaption aria-hidden="true">IMG_256</figcaption></figure><p>主体、资源、权限相关的数据模型如下：</p><p>主体（用户id、账号、密码、...）</p><p>资源（资源id、资源名称、访问地址、...）</p><p>权限（权限id、权限标识、权限名称、资源id、...）</p><p>角色（角色id、角色名称、...）</p><p>角色和权限关系（角色 id、权限id、...）</p><p>主体（用户）和角色关系（用户id、角色id、...）</p><p>主体（用户）、资源、权限关系如下图：</p><figure><img data-src="D:\Pictures\typore\clip_image002-17150487703522.jpg" alt="IMG_257"><figcaption aria-hidden="true">IMG_257</figcaption></figure><p>通常企业开发中将资源和权限表合并为一张权限表，如下：</p><p>资源（资源id、资源名称、访问地址、...）</p><p>权限（权限id、权限标识、权限名称、资源id、...）</p><p>合并为：</p><p>权限（权限id、权限标识、权限名称、资源名称、资源访问地址、...）</p><p>修改后数据模型之间的关系如下图：</p><figure><img data-src="D:\Pictures\typore\clip_image002-17150487790833.jpg" alt="IMG_258"><figcaption aria-hidden="true">IMG_258</figcaption></figure><h4 id="rbac">5、RBAC</h4><p>用户，角色，权限 本质：就是把权限打包给角色，分配给用户</p><p><strong>RBAC一般指基于角色的访问控制</strong> 权限 五张表 （最少五张表）</p><p>基于角色的访问控制（RBAC）是实施面向企业安全策略的一种有效的访问控制方式。</p><p>系统的资源访问级别会更加细化</p><p><strong>1 基于角色的访问控制</strong></p><p>RBAC基于角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等</p><p>根据上图中的判断逻辑，授权代码可表示如下：</p><p><strong>if(主体.hasRole("总经理角色id")){</strong></p><p><strong>查询工资</strong></p><p><strong>}</strong></p><p>如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”，修改代码如下：</p><p><strong>if(主体.hasRole("总经理角色id") ||</strong> <strong>主体.hasRole("部门经理角色id")){</strong></p><p><strong>查询工资</strong></p><p><strong>}</strong></p><p>根据上边的例子发现，当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。</p><p><strong>2 基于权限的访问控制</strong></p><p>RBAC基于资源的访问控制（Resource-Based Access Control）是按资源（或权限）进行授权，比如：用户必须具有查询工资权限才可以查询员工工资信息等，如下的判断</p><p><strong>if(主体.hasPermission("查询工资") ){</strong></p><p><strong>查询工资</strong></p><p><strong>}</strong></p><p>优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。</p><h3 id="二spring-security简介">二、Spring Security简介</h3><p>官网： https://spring.io/projects/spring-security</p><p>中文文档： https://www.springcloud.cc/spring-security.html</p><h4 id="什么是spring-security">1、什么是Spring Security</h4><p>Spring Security是一个能够为基于Spring的企业应用系统提供<strong>声明式（注解）的安全访问控制解决方案的安全框架</strong>。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><p>以上解释来源于百度百科。可以一句话来概括，SpringSecurity 是一个安全框架。</p><h3 id="三jwt概述">三、JWT概述</h3><h4 id="什么是jwt">1、什么是JWT</h4><p><strong>Json web token (JWT)</strong>, 是<strong>为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准</strong>（(RFC 7519).该token被设计为<strong>紧凑且安全</strong>的，特别适用于<strong>分布式站点的单点登录（</strong>SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><p>官网： <a target="_blank" rel="noopener" href="https://jwt.io/"><strong>https://jwt.io/</strong></a></p><h4 id="跨域认证问题">2、跨域认证问题</h4><p>互联网服务离不开用户认证。一般流程是下面这样。</p><p>l 用户向服务器发送用户名和密码。</p><p>l 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>l 服务器向用户返回一个 session_id，写入浏览器的 Cookie。（Cookie不能跨域携带）</p><p>l 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>l 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p><strong>一种解决方案是 session</strong> <strong>数据持久化</strong>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p><strong>另一种方案是服务器索性不保存 session</strong> <strong>数据了，所有数据都保存在客户端，每次请求都发回服务器</strong>。JWT 就是这种方案的一个代表。 服务器不存数据，客户端存，服务器解析就行了</p><h4 id="jwt原理">3、JWT原理</h4><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><p>{ "姓名": "张三", "角色": "管理员", "到期时间": "2018年7月1日0点0分" }</p><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加<strong>上签名</strong>（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成<strong>无状态</strong>了，从而比较容易实现扩展。</p><h4 id="jwt数据结构">4、JWT数据结构</h4><p>实际的 JWT 大概就像下面这样。</p><figure><img data-src="D:\Pictures\typore\clip_image002-17150492894634.png" alt="IMG_256"><figcaption aria-hidden="true">IMG_256</figcaption></figure><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><p>面试问题： jwt知道吗？谈谈你的理解（由浅入深的聊）</p><p>Ø Header（头部）</p><p>Ø Payload（负载）</p><p>Ø Signature（签名）</p><p>写成一行，就是下面的样子。</p><figure><img data-src="D:\Pictures\typore\clip_image002-17150492956465.png" alt="IMG_257"><figcaption aria-hidden="true">IMG_257</figcaption></figure><p><strong>1、Header</strong></p><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><p>最后，将上面的 JSON 对象使用 <strong>Base64URL</strong> <strong>算法转成字符串</strong>。</p><p><strong>2、Payload</strong></p><p>Payload 部分也是一个 JSON 对象，用来存放<strong>实际需要传递的数据</strong>。JWT 规定了7个官方字段，供选用。</p><p>iss (issuer)：签发人</p><p><strong>exp (expiration time)：过期时间</strong></p><p>sub (subject)：主题</p><p>aud (audience)：受众</p><p>nbf (Not Before)：生效时间</p><p><strong>iat (Issued At)：签发时间</strong></p><p>jti (JWT ID)：编号</p><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把<strong>秘密信息（密码，手机号等）</strong>放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><p><strong>3、Signature（保证数据安全）</strong></p><p>Signature 部分是对前两部分的签名，<strong>防止数据篡改</strong>。</p><p>钥匙：一个字符串 秘钥 abcdefg 对称加密 非对称加密 A B</p><p>首先，需要指定一个<strong>密钥（secret）</strong>。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。</p><p><strong>4、Base64URL（转码）</strong></p><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。</p><p>Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 <strong>Base64URL 算法</strong>。</p><h4 id="jwt的使用方式重点">5、JWT的使用方式【重点】</h4><p><strong>客户端收到服务器返回的 JWT，可以储存在 Cookie</strong> <strong>里面，也可以储存在 localStorage</strong></p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP请求的头信息Authorization字段里面</p><p><strong>Authorization: Bearer jwt</strong></p><p><strong>另一种做法是，跨域的时候，JWT</strong> <strong>就放在 POST</strong> <strong>请求的数据体里面。</strong></p><h4 id="jwt的特点">6、JWT的特点</h4><p>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑（JWT的登出问题）。就是因为服务端无状态了</p><p>正常情况下 修改了密码后就会跳转到登录页面 ：修改成功后清空浏览器保存的token了</p><p>后端怎么玩？ 因为服务端不保留token 我用之前的token 还是可以继续访问的</p><p>从有状态（后端也会存一个）的变成无状态的了</p><p>我们就要把它从无状态再变成有状态了</p><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><p>我们颁发一个令牌 用户名称 用户的权限信息 这个令牌2个小时有效</p><p>Jwt只要能解析 就认为你是可用的 做不了 登出 后端不存储用户信息了 后端无状态了</p><h1 id="docker">---09-Docker</h1><h3 id="一docker简介">一、Docker简介</h3><p>1、什么是Docker</p><p>​ Docker是一个开源项目，<strong>它的目标是实现经量级的操作系统虚拟化解决方案。Docker是一种容器技术。Docker的基础是Linux容器（LXC）等技术。在LXC的基础上Docker进行了进一步的封装，让用户不需要关心容器的管理，使得操作更加简单。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。</strong></p><p>2、Docker设计思想</p><p>​ Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。</p><p>通过Docker能够把 net，php开发的应用作为容器（集装箱）运行。net和php开发的两个应用是各自独立的环境。基于容器（集装箱）可以运行多种应用，redis，mysql，tomcat，centos等等。总之Docker就是集装箱原理。</p><p>3、为什么要使用Docker</p><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。首先，<strong>Docker</strong> <strong>容器的启动可以在秒级实现</strong>，这相比传统的虚拟机方式要快得多。其次，<strong>Docker</strong> <strong>对系统资源的利用率很高，一台主机上可以同时运行数千个Docker</strong> <strong>容器</strong>。</p><p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。</p><p>传统虚拟机方式运行10 个不同的应用就要起10 个虚拟机，而Docker 只需要启动10 个隔离的应用即可。具体说来，Docker 在如下几个方面具有较大的优势。</p><ol type="1"><li>更快速的交付和部署</li><li>更轻松的迁移和扩展</li><li>更简单的管理</li></ol><p>4、Docker的局限</p><ol type="1"><li><strong>Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用</strong></li><li>隔离性相比虚拟机之类的虚拟化方案还是有些欠缺，所有容器公用一部分的运行库</li><li><strong>网络管理相对简单</strong></li><li>Docker对磁盘的管理比较有限</li><li><strong>容器随着用户进程的停止而销毁，容器中的日志等用户数据不便收集</strong></li></ol><h3 id="二掌握docker说明">二、【掌握】Docker说明</h3><p>官网 http://www.docker.com</p><p>中文官网 https://docker-cn.com</p><p>仓库（镜像网站） https://hub.docker.com</p><div class="tags"><a href="/tags/Spring-Cloud/" rel="tag"><i class="ic i-tag"></i> Spring Cloud</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-07-27 11:20:53" itemprop="dateModified" datetime="2024-07-27T11:20:53+08:00">2024-07-27</time> </span><span id="2024/06/27/post/cloud/分布式SpringCloud阿里巴巴/" class="item leancloud_visitors" data-flag-title="分布式Spring Cloud阿里巴巴-理论" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>ZoroJan <i class="ic i-at"><em>@</em></i>CYX</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/06/27/post/cloud/%E5%88%86%E5%B8%83%E5%BC%8FSpringCloud%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/" title="分布式Spring Cloud阿里巴巴-理论">http://example.com/2024/06/27/post/cloud/分布式SpringCloud阿里巴巴/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/06/27/post/job/03-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;11.png" title="03-实现图片压缩"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 工作日志</span><h3>03-实现图片压缩</h3></a></div><div class="item right"><a href="/2024/06/27/post/cloud/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;10.png" title="云服务器部署-基础版本（前后端）"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 微服务框架</span><h3>云服务器部署-基础版本（前后端）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fspring-cloud%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4"><span class="toc-number">1.</span> <span class="toc-text">分布式Spring Cloud阿里巴巴</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spring-cloud"><span class="toc-number">2.</span> <span class="toc-text">---01-Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">一、微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">1、什么是微服务架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">2、微服务架构的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9spring-cloud-%E6%9D%A5%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">3、为什么选择Spring Cloud 来构建微服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8Cspring-cloud"><span class="toc-number">2.1.1.</span> <span class="toc-text">二、Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-cloud%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1、Spring Cloud是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2、整体框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83eureka"><span class="toc-number">2.1.2.</span> <span class="toc-text">三、服务注册中心Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B0%E8%BF%9B%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83eureka"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1、走进服务中心Eureka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eureka%E4%B8%8Ezookeeper%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2、Eureka与Zookeeper的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1ribbon"><span class="toc-number">2.1.3.</span> <span class="toc-text">四、客户端负载均衡Ribbon</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1、负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ribbon%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">2、Ribbon介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ribbon-%E4%B8%8E-nginx-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">3、Ribbon 与 Nginx 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">4、使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94resttemplate%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.1.4.</span> <span class="toc-text">五、RestTemplate模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%ADhystrix"><span class="toc-number">2.1.5.</span> <span class="toc-text">六、服务熔断Hystrix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hystrix%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">1、Hystrix是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9feign"><span class="toc-number">2.1.6.</span> <span class="toc-text">七、声明式服务消费Feign</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fegin%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">1、Fegin介绍</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#nacos"><span class="toc-number">3.</span> <span class="toc-text">----02-Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80springcloudalibab%E7%AE%80%E4%BB%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">一、springCloudAlibab简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8Cnacos"><span class="toc-number">3.0.2.</span> <span class="toc-text">二、Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFnacos"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">1、什么是nacos</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">2、使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sentinel"><span class="toc-number">4.</span> <span class="toc-text">----03-Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80sentinel"><span class="toc-number">4.0.1.</span> <span class="toc-text">一、Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinel%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">1、Sentinel是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">2、主要功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gateway"><span class="toc-number">5.</span> <span class="toc-text">---04-GateWay</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%AE%A4%E8%AF%86gateway"><span class="toc-number">5.0.1.</span> <span class="toc-text">一、认识GateWay</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-cloud%E7%9A%84gateway"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">1、 Spring Cloud的Gateway</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rocketmq"><span class="toc-number">6.</span> <span class="toc-text">---05-RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80rocketmq%E6%A6%82%E8%BF%B0"><span class="toc-number">6.0.1.</span> <span class="toc-text">一、RocketMQ概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">1、什么是消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">2、为什么要使用消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B516%E6%9D%A1"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">3、RocketMQ基本概念（16条）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq%E7%89%B9%E6%80%A7"><span class="toc-number">6.0.1.4.</span> <span class="toc-text">4、RocketMQ特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seata"><span class="toc-number">7.</span> <span class="toc-text">---06-Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.0.1.</span> <span class="toc-text">一、分布式事务介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8Cseata%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.0.2.</span> <span class="toc-text">二、Seata介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">1、相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#at%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">2、AT模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E6%8F%90%E4%BA%A4"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">3 二阶段-提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcc%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.2.4.</span> <span class="toc-text">3、TCC模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#saga%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.2.5.</span> <span class="toc-text">4、SAGA模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xa%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.2.6.</span> <span class="toc-text">5、XA模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sky-walking%E9%93%BE%E5%BC%8F%E8%B7%9F%E8%B8%AA"><span class="toc-number">8.</span> <span class="toc-text">---07-Sky Walking链式跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80sky-walking%E7%AE%80%E4%BB%8B"><span class="toc-number">8.0.1.</span> <span class="toc-text">一、Sky Walking简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD-1"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">1、主要功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">8.0.1.2.</span> <span class="toc-text">2、总体框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spring-security"><span class="toc-number">9.</span> <span class="toc-text">---08-Spring Security</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">9.0.1.</span> <span class="toc-text">一、认证授权的基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">1、什么是认证（登录）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">2、什么是会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83%E7%BB%99%E7%94%A8%E6%88%B7%E9%A2%81%E5%8F%91%E6%9D%83%E9%99%90"><span class="toc-number">9.0.1.3.</span> <span class="toc-text">3、什么是授权（给用户颁发权限）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8Brbac"><span class="toc-number">9.0.1.4.</span> <span class="toc-text">4、授权的数据模型（RBAC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rbac"><span class="toc-number">9.0.1.5.</span> <span class="toc-text">5、RBAC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8Cspring-security%E7%AE%80%E4%BB%8B"><span class="toc-number">9.0.2.</span> <span class="toc-text">二、Spring Security简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-security"><span class="toc-number">9.0.2.1.</span> <span class="toc-text">1、什么是Spring Security</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89jwt%E6%A6%82%E8%BF%B0"><span class="toc-number">9.0.3.</span> <span class="toc-text">三、JWT概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjwt"><span class="toc-number">9.0.3.1.</span> <span class="toc-text">1、什么是JWT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98"><span class="toc-number">9.0.3.2.</span> <span class="toc-text">2、跨域认证问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt%E5%8E%9F%E7%90%86"><span class="toc-number">9.0.3.3.</span> <span class="toc-text">3、JWT原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.0.3.4.</span> <span class="toc-text">4、JWT数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E9%87%8D%E7%82%B9"><span class="toc-number">9.0.3.5.</span> <span class="toc-text">5、JWT的使用方式【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">9.0.3.6.</span> <span class="toc-text">6、JWT的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker"><span class="toc-number">10.</span> <span class="toc-text">---09-Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80docker%E7%AE%80%E4%BB%8B"><span class="toc-number">10.0.1.</span> <span class="toc-text">一、Docker简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%8E%8C%E6%8F%A1docker%E8%AF%B4%E6%98%8E"><span class="toc-number">10.0.2.</span> <span class="toc-text">二、【掌握】Docker说明</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/06/27/post/cloud/%E5%88%86%E5%B8%83%E5%BC%8FSpringCloud%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/" rel="bookmark" title="分布式Spring Cloud阿里巴巴-理论">分布式Spring Cloud阿里巴巴-理论</a></li><li><a href="/2024/06/27/post/cloud/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/" rel="bookmark" title="云服务器部署-基础版本（前后端）">云服务器部署-基础版本（前后端）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="ZoroJan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">ZoroJan</p><div class="description" itemprop="description">我的个人博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">38</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">25</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0k4Wm9ybzhJ" title="https:&#x2F;&#x2F;github.com&#x2F;I8Zoro8I"><i class="ic i-github"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMTc5NDkxNDQ4P3NwbV9pZF9mcm9tPTMzMy4xMDA3LjAuMA==" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;179491448?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTEzMDk4Mzg3OTU=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1309838795"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNjMzOTY2OTQ3Mg==" title="https:&#x2F;&#x2F;weibo.com&#x2F;6339669472"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="bWFpbHRvOm0xNTg2MDg2MDM4NkAxNjMuY29t" title="mailto:m15860860386@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链环</a><ul class="submenu"><li class="item"><a href="/site/" rel="section"><i class="ic i-star"></i>网站</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/06/27/post/job/03-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/06/27/post/cloud/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/job/" title="分类于 工作日志">工作日志</a></div><span><a href="/2024/07/01/post/job/04-%E5%9B%BD%E9%99%85%E5%8C%96%E6%93%8D%E4%BD%9Ci18n/" title="04-国际化操作i18n">04-国际化操作i18n</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springboot/" title="分类于 后端">后端</a></div><span><a href="/2024/06/09/post/springboot/01-java%E6%B5%81-Stream/" title="01-Java流-Stream">01-Java流-Stream</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/utils/" title="分类于 实用小工具">实用小工具</a></div><span><a href="/2024/06/28/post/utils/utils/" title="实用小工具">实用小工具</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springboot/" title="分类于 后端">后端</a></div><span><a href="/2024/07/16/post/springboot/04-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2024/08/26/post/golang/6-Gin-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/" title="6-Gin-参数&#x2F;数据解析">6-Gin-参数/数据解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/job/" title="分类于 工作日志">工作日志</a></div><span><a href="/2024/07/01/post/job/06-%E7%8F%A0%E5%95%A4%E5%BC%80%E5%8F%91%E4%BB%BB%E5%8A%A1%E5%B0%8F%E8%AE%B0/" title="06-珠啤开发任务小记">06-珠啤开发任务小记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/job/" title="分类于 工作日志">工作日志</a></div><span><a href="/2024/06/16/post/job/01-git%E6%8B%89%E5%8F%96%E9%A1%B9%E7%9B%AE/" title="01-如何使用git拉取项目">01-如何使用git拉取项目</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/sql/" title="分类于 数据库">数据库</a></div><span><a href="/2024/07/03/post/sql/01-sql/" title="数据库">数据库</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue/" title="分类于 前端">前端</a></div><span><a href="/2024/07/15/post/vue/D3.js%20%20%20V3%E7%89%88%E6%9C%AC/" title="D3.js V3版本  学习笔记">D3.js V3版本 学习笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2024/08/26/post/golang/5-Gin-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/" title="5-Gin-快速开始">5-Gin-快速开始</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">ZoroJan @ ZoroJan-个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">262k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:58</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/06/27/post/cloud/分布式SpringCloud阿里巴巴/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->