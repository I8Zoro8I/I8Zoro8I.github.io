<!-- build time:Tue Aug 27 2024 14:59:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CYX" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="CYX" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="CYX" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="标标备忘录,算法"><link rel="canonical" href="http://example.com/2024/06/10/post/biao/shor/Shor%20algorithm/"><title>Shor算法详解 - Shor算法详解 - 标标备忘录 | ZoroJan-个人博客 = CYX = Blog</title><meta name="generator" content="Hexo 7.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Shor算法详解</h1><div class="meta"><span class="item" title="创建时间：2024-06-10 13:42:16"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-06-10T13:42:16+08:00">2024-06-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">ZoroJan-个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/assets/7.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/biao/" itemprop="item" rel="index" title="分类于 标标备忘录"><span itemprop="name">标标备忘录</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/biao/shor/" itemprop="item" rel="index" title="分类于 Shor算法详解"><span itemprop="name">Shor算法详解</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/06/10/post/biao/shor/Shor%20algorithm/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="ZoroJan"><meta itemprop="description" content="Blog, 我的个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CYX"></span><div class="body md" itemprop="articleBody"><h1 id="shor算法详解">Shor算法详解</h1><p>量子计算理论中一个重要的结论是：「所有经典图灵机都可以用量子电路实现」，也就是说量子计算机至少拥有经典计算机的计算能力。超越经典计算机的能力被称为Quantum Supermacy。</p><p>Shor算法解决的问题是「任何合数的质因数分解」——输入21，输出3×7；输入3233，输出53×61。在经典计算理论中，质因数分解算法在不断优化，但是至今仍然没有发现一个多项式复杂度的算法。不仅如此，也没有人能从反方向证明质因数分解是一个<strong>NP Complete</strong>问题。</p><p>算法整体的大致脉络：</p><ol type="1"><li><p>因数分解问题——对于任意合数n，希望找到它的一个因数p : 1&lt;p&lt;n（这里不要求p为质数）；</p></li><li><p>我们将证明，如果能够解决另外一个所谓「模n周期」问题（Order finding problem)，那么就可以利用该问题的解来搞定因数分解问题（两个问题的转化只需要经典算法）；</p></li><li><p>「模n周期」问题的求解可以分为两个步骤</p><ol type="i"><li>第一步是量子算法，用到一个叫「相位估计」（Phase estimation）的量子电路得到中间解；</li><li>第二步用到的是连分数（Continued fraction）的经典（非量子）算法将中间解转化为最终「模n周期」的解</li></ol></li><li><p>「相位估计」量子电路具有以下特点</p><ol type="i"><li>输入状态是实验室条件下易准备的状态；</li><li>输出的测量结果成功概率可以通过输入状态精度进行调控。</li></ol></li></ol><p>最终结果是，我们整体上获得了一个经典+量子混合的一个概率算法</p><ul><li><p>复杂度为<span class="math inline">\(O(\log(n)^3\)</span>，远低于多项式复杂度；</p></li><li><p>通过调整输入精度能够以任意接近于1的概率得到一个正确的结果</p></li></ul><h2 id="因数分解问题到模n周期问题的转化">「因数分解」问题到「模n周期」问题的转化</h2><p><strong>定义</strong>：给定正整数n，和与之互质的的整数<span class="math inline">\(x：1 &lt; x &lt; n\)</span>，满足以下条件</p><p><span class="math display">\[ x^r-1=0 \pmod n \]</span></p><p>的最小正整数<span class="math inline">\(r\)</span>，称为 $ x $ 的「模n周期」，简称周期。</p><p>例：令 <span class="math inline">\(n=18,x=11\)</span>：</p><p><span class="math display">\[ \begin{aligned} &amp;11^1=11&amp;\pmod {18}\\ &amp;11^2=121=13&amp;\pmod {18}\\ &amp;11^3=1331=17&amp;\pmod{18}\\ &amp;11^4=14641=7&amp;\pmod{18}\\ &amp;11^5=161051=5&amp;\pmod{18}\\ &amp;11^6=1771561=1&amp;\pmod{18}\\ \end{aligned} \]</span></p><p>因此对于模n=18，x=11的周期为r=6.</p><p><strong>命题</strong>：若<span class="math inline">\(\gcd(x,n)=1\)</span>，则周期一定存在。</p><p><strong>证明</strong>：考虑 <span class="math inline">\(x\)</span> 的各级幂在模n下的余数</p><p><span class="math display">\[ x^1,x^2,\cdots,x^{n-1},x^n\pmod n \]</span></p><p>由于<span class="math inline">\(\gcd(x,n)=1\)</span>，则上列各数都非零，从而上列诸数只能从1到n-1中取值。由鸽巢原理可知，故必有两者取值相同，记为</p><p><span class="math display">\[ x^j=x^k\pmod n \]</span></p><p>但由于<span class="math inline">\(x\neq0\pmod n\)</span>，因此<span class="math inline">\(r=|j-k|\)</span>满足周期性要求<span class="math inline">\(x^n=1\pmod n\)</span>。</p><p>若周期 <span class="math inline">\(r\)</span> 是偶数，则我们可以将周期的定义等价改写为</p><p><span class="math display">\[ (x^{r/2}-1)(x^{r/2}+1)=0\pmod n \]</span></p><p>n整除上式左边的两个乘积。但由于周期r定义中的最小性， <span class="math inline">\(x^{r/2}-1\)</span> 不可能为0，而如果此时 <span class="math inline">\(x^{r/2}+1\)</span>也不为零，那么</p><p><span class="math display">\[ \gcd(x^{r/2}-1,n),\qquad \gcd(x^{r/2}+1,n) \]</span></p><p>二者之中至少一个是n的因数。</p><p><strong>总结</strong>：我们随机选定一个与n互质的数x：1 &lt; x &lt; n，求得它的周期r，如果r满足以下两个条件——称为【好周期条件】</p><ol type="1"><li><p>r 是偶数；</p></li><li><p><span class="math inline">\(x^{r/2}+1\neq0\pmod n\)</span></p></li></ol><p>那么我们就可以通过最大公约数gcd操作获得n的一个因数，而众所周知，求最大公约数的问题存在log(n) 复杂度的经典算法（即「辗转相除法」或者Euclid Algorithm）。由此我们便解决了因数分解问题。</p><p>下表列出了所有与n互质的x、x的周期r以及  的值，并在最后一列标注r是否满足【好周期条件】。我们看到，对于n=33，一共有20个x与n互质，而其中10个满足条件。</p><figure><img src="https://pic2.zhimg.com/80/v2-971e98aeb4f10c1511cdaa9118517df1_720w.webp" alt="v2-971e98aeb4f10c1511cdaa9118517df1_720w"><figcaption aria-hidden="true">v2-971e98aeb4f10c1511cdaa9118517df1_720w</figcaption></figure><p><strong>好周期概率定理</strong>：若某个奇合数的质因数分解为如下形式</p><p><span class="math display">\[ n=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_m^{\alpha_m} \]</span></p><p>令<span class="math inline">\(x：1&lt;x&lt;n\)</span>为随机选取的与n互质的整数，则x的周期r满足【好周期条件】的概率不低于<span class="math inline">\(1-\frac{1}{2^{m-1}}\)</span>.</p><figure><img src="https://pic1.zhimg.com/80/v2-82f9fdd57bc0592d0cb0ba1a5e385714_720w.webp" alt="v2-82f9fdd57bc0592d0cb0ba1a5e385714_720w"><figcaption aria-hidden="true">v2-82f9fdd57bc0592d0cb0ba1a5e385714_720w</figcaption></figure><p>现在问题的<strong>核心</strong>就转移到：给定n和与之互质的x，如何寻找x的周期r。</p><h1 id="rsa加密算法">RSA加密算法</h1><h2 id="操作">1.操作</h2><h3 id="公钥与私钥的产生">公钥与私钥的产生</h3><p>假设<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%84%9B%E9%BA%97%E7%B5%B2%E8%88%87%E9%AE%91%E4%BC%AF" title="爱丽丝与鲍伯">Alice</a>想要通过不可靠的媒体接收Bob的私人消息。她可以用以下的方式来产生一个<strong>公钥</strong>和一个<strong>私钥</strong></p><p>(1) 随意选择两个不相等的大素数<span class="math inline">\(p,q\)</span>，计算<span class="math inline">\(N=pq\)</span>；</p><p>(2) 根据欧拉函数，求得<span class="math inline">\(r=\varphi(N)=\varphi(p)\varphi(q)=(p-1)(q-1)\)</span>；</p><p>(3) 选择一个小于<span class="math inline">\(r\)</span>的整数<span class="math inline">\(e\)</span>，且满足<span class="math inline">\(\gcd(r,e)=1\)</span>，并求得<span class="math inline">\(e\)</span>关于<span class="math inline">\(r\)</span>的模逆元，记为<span class="math inline">\(d\)</span>（即求<span class="math inline">\(ex\equiv1\pmod r\)</span>的解）；</p><p>(4) 将<span class="math inline">\(p,q\)</span>的记录销毁。</p><p><span class="math inline">\((N,e)\)</span>是公钥，<span class="math inline">\((N,d)\)</span>是私钥。Alice将她的公钥<span class="math inline">\((N,e)\)</span>传给Bob，而将她的私钥<span class="math inline">\((N,d)\)</span>藏起来。</p><h3 id="加密信息">加密信息</h3><p>假设Bob想给Alice送消息<span class="math inline">\(m\)</span>，他知道Alice产生的<span class="math inline">\(N\)</span>和<span class="math inline">\(e\)</span>。他使用起先与Alice约好的格式将<span class="math inline">\(m\)</span>转换为一个小于<span class="math inline">\(N\)</span>的非负整数<span class="math inline">\(n\)</span>，比如他可以将每一个字转换为这个字的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode" title="Unicode">Unicode</a>码，然后将这些数字连在一起组成一个数字。假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为<span class="math inline">\(n\)</span>。利用公式 <span class="math inline">\(c=n^e\pmod N\)</span> 可以将 <span class="math inline">\(n\)</span> 加密为 <span class="math inline">\(c\)</span>，这里的<span class="math inline">\(c\)</span>可以用模幂算法快速求出来。Bob算出<span class="math inline">\(c\)</span>后可将它转递给Alice。</p><h3 id="解密信息">解密信息</h3><p>Alice得到Bob的消息 <span class="math inline">\(c\)</span> 后就可以利用密钥 <span class="math inline">\(d\)</span> 来解码，利用公式<span class="math inline">\(n=c^d\pmod N\)</span>将 <span class="math inline">\(c\)</span> 转化为<span class="math inline">\(n\)</span>；</p><p>解码的原理为：</p><p><span class="math display">\[ c^d\equiv n^{e\cdot d}\pmod N \]</span></p><p>已知 <span class="math inline">\(ed\equiv1\pmod r\)</span>，即 <span class="math inline">\(ed=1+h\varphi(N)\)</span>。那么有</p><p><span class="math display">\[ n^{ed}=n^{1+h\varphi(N)}=n\cdot n^{h\varphi(N)}=n(n^{\varphi(N)})^h \]</span></p><p>若 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(N\)</span> 互素，则由欧拉定理得：</p><p><span class="math display">\[ n^{ed}\equiv n(n^{\varphi(N)})^h\equiv n(1)^h\equiv n \pmod N \]</span></p><p>若 n 与 N 不互素，则不失一般性考虑 <span class="math inline">\(n=ph\)</span> 以及 <span class="math inline">\(ed-1=k(q-1)\)</span>,得：</p><p><span class="math display">\[ \begin{aligned} &amp;n^{ed}=(ph)^{ed}\equiv0 \equiv ph\equiv n\pmod p\\ &amp;n^{ed}=n^{ed-1}n=n^{k(q-1)}n=(n^{q-1})^kn\equiv 1^kn\equiv n\pmod q \end{aligned} \]</span></p><p>因此 <span class="math inline">\(n^{ed}\equiv n\pmod N\)</span> 得证。</p><h3 id="签名信息">签名信息</h3><p>RSA也可以用来为一个消息署名。假如Alice想给Bob传递一个署名的消息的话，那么她可以为她的消息计算一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97" title="散列">散列值</a>（Message digest），然后用她的私钥“加密”（如同前面“加密消息”的步骤）这个散列值并将这个“署名”加在消息的后面。这个消息只有用她的公钥才能被解密。Bob获得这个消息后可以用Alice的公钥“解密”（如同前面“解密消息”的步骤）这个散列值，然后将这个数据与他自己为这个消息计算的散列值相比较。假如两者相符的话，那么Bob就可以知道发信人持有Alice的<strong>私钥</strong>，以及这个消息在传播路径上没有被篡改过。</p><h3 id="正确性证明">正确性证明</h3><p>首先取两个互素数 <span class="math inline">\(p,q\)</span>，计算<span class="math inline">\(p\cdot q\)</span> 得到 <span class="math inline">\(N\)</span>.</p><p>然后计算欧拉函数<span class="math inline">\(\phi(N)\)</span>，由于 <span class="math inline">\(p,q\)</span> 都是素数，因此 <span class="math inline">\(\phi(N)=(p-1)(q-1)\)</span>.</p><p>这时我们随机选择一个整数<span class="math inline">\(e\)</span>，满足<span class="math inline">\(1&lt;e&lt;\phi(N)\)</span>，且<span class="math inline">\(\gcd(e,\phi(N)=1\)</span>,接着计算 <span class="math inline">\(d\)</span> 满足 <span class="math inline">\(cd\equiv 1\pmod {\phi(N)}\)</span>。即<span class="math inline">\(ed=k(p-1)(q-1)+1\)</span></p><hr><p>于是，RSA公钥为<span class="math inline">\((N,e)\)</span>,私钥为<span class="math inline">\((N,d)\)</span>。</p><p>加密原文 <span class="math inline">\(m\)</span> 得到密文 <span class="math inline">\(x=m^e\pmod N\)</span></p><p>解密公式为 <span class="math inline">\(m=x^d\pmod N\)</span></p><hr><h3 id="证明解密逻辑">证明解密逻辑</h3><p>在<span class="math inline">\(m&lt;N\)</span>的状况下证明<span class="math inline">\(m=x^d\pmod N\)</span>，即证明<span class="math inline">\(x^d\pmod N -m=0\)</span></p><p><span class="math display">\[ \begin{aligned} &amp;x^d\%N-m\\ &amp;=(m^e\%N)^d\%N-m\\ &amp;=m^{ed}\%N-m\\ &amp;=m^{k(p-1)(q-1)+1}\%N-m\\ &amp;=m\cdot (m^{k(p-1)(q-1)-1})\%N \end{aligned} \]</span></p><p>当<span class="math inline">\(\gcd(m,N)=1\)</span>时，由费马小定理可知：</p><p>$$ (m<sup>{k(q-1)})</sup>{p-1}p\ (m<sup>{k(p-1)})</sup>{q-1}q\ m^{k(p-1)(q-1)}\ m^{k(p-1)(q-1)}\</p><p>m(m^{k(p-1)(q-1)}-1)%N=0 $$</p><p>当 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(N\)</span> 不互质时，不失一般性设公因子为 <span class="math inline">\(p\)</span>，即 <span class="math inline">\(m=ph_1(h_1&lt;q)\)</span></p><p>假设 <span class="math inline">\(q\mid m\)</span>，从而<span class="math inline">\(q\mid ph_1\)</span>。由于 <span class="math inline">\(p,q\)</span> 互素，从而 <span class="math inline">\(q\mid h_1\)</span>，因此 <span class="math inline">\(q\leq h_1\)</span> 矛盾，所以 <span class="math inline">\(q\)</span> 不整除 <span class="math inline">\(m\)</span>。</p><p>此时 <span class="math inline">\(m,q\)</span> 互素，根据费马小定理：</p><p><span class="math display">\[ \begin{aligned} &amp;m^{q-1}\equiv 1\pmod q\\ &amp;\Rightarrow m^{k(p-1)(q-1)}\equiv 1\pmod q\\ &amp;\Rightarrow m^{k(p-1)(q-1)}-1=qh_2\\ &amp;\Rightarrow m\cdot (m^{k(p-1)(q-1)}-1)\%N=ph_1\cdot qh_2\%N=0. \end{aligned} \]</span></p><h3 id="安全性">安全性</h3><p>假设偷听者Eve获得了Alice的公钥<span class="math inline">\(N,e\)</span>以及Bob的加密消息 <span class="math inline">\(c\)</span>，但她无法直接获得Alice的密钥 <span class="math inline">\(d\)</span>，要获得 <span class="math inline">\(d\)</span>，最简单的方法是将 <span class="math inline">\(N\)</span>分解成<span class="math inline">\(p,q\)</span>，这样得到同余方程<span class="math inline">\(de\equiv 1\pmod {(p-1)(q-1)}\)</span>并解出<span class="math inline">\(d\)</span> ,然后代入解密公式 <span class="math inline">\(c^d\equiv n \pmod N\)</span>导出 <span class="math inline">\(n\)</span>。</p><p>但至今为止还没有人找到一个多项式时间的算法来分解一个大的整数的因子，同时也还没有人能够证明这种算法不存在。至今为止也没有人能够证明对<span class="math inline">\(N\)</span>进行因数分解是唯一的从 <span class="math inline">\(c\)</span> 导出 <span class="math inline">\(n\)</span> 的方法，直到今天也还没有找到比它更简单的方法。</p><p>假如<span class="math inline">\(N\)</span>的长度小于或等于256位，那么用一台个人电脑在几个小时内就可以分解它的因子了。1999年，数百台电脑合作分解了一个512位长的<span class="math inline">\(N\)</span>。一个由Shamir 和Tromer在2003年从理论上构建的硬件TWIRL，使人们开始质疑1024位长的<span class="math inline">\(N\)</span>的安全性，目前推荐<span class="math inline">\(N\)</span>的长度至少为2048位。</p><p>1994年，彼得·秀尔证明一台<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA" title="量子计算机">量子计算机</a>可以在多项式时间内进行因数分解。假如量子计算机有朝一日可以成为一种可行的技术的话，那么秀尔的算法可以淘汰RSA和相关的派生算法。（即依赖于分解大整数困难性的加密算法）</p><hr><h2 id="实现细节">实现细节</h2><h3 id="密钥生成">密钥生成</h3><p>首先要使用概率算法来验证随机产生的大的整数是否质数，这样的算法比较快而且可以消除掉大多数非质数。假如有一个数通过了这个测试的话，那么要使用一个精确的测试来保证它的确是一个质数。</p><p>除此之外这样找到的<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>还要满足一定的要求，首先它们不能太靠近，此外<span class="math inline">\(p-1\)</span>或<span class="math inline">\(q-1\)</span>的因子不能太小，否则的话<span class="math inline">\(N\)</span>也可以被很快地分解。 此外寻找质数的算法不能给攻击者任何信息，这些质数是怎样找到的，尤其产生随机数的软件必须非常好。要求是随机和不可预测。这两个要求并不相同。一个随机过程可能可以产生一个不相关的数的系列，但假如有人能够预测出(或部分地预测出)这个系列的话，那么它就已经不可靠了。比如有一些非常好的随机数算法，但它们都已经被发表，因此它们不能被使用，因为假如一个攻击者可以猜出<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>一半的位的话，那么他们就已经可以轻而易举地推算出另一半。 此外密钥<span class="math inline">\(d\)</span>必须足够大，1990年有人证明假如<span class="math inline">\(p\)</span>大于<span class="math inline">\(q\)</span>而小于2<span class="math inline">\(q\)</span> (这是一个很常见的情况)而 <span class="math inline">\(d&lt;\frac{1}{3}\times N^{\frac{1}{4}}\)</span>,那么从<span class="math inline">\(N\)</span>和<span class="math inline">\(e\)</span>可以很有效地推算出<span class="math inline">\(d\)</span>。此外<span class="math inline">\(e=2\)</span>永远不应该被使用。</p><h3 id="密钥分配">密钥分配</h3><p>和其它加密过程一样，对RSA来说分配公钥的过程是非常重要的。分配公钥的过程必须能够抵挡中间人攻击。假设Eve交给Bob一个公钥，并使Bob相信这是Alice的公钥，并且她可以截下Alice和Bob之间的信息传递，那么她可以将她自己的公钥传给Bob，Bob以为这是Alice的公钥。Eve可以将所有Bob传递给Alice的消息截下来，将这个消息用她自己的密钥解密，读这个消息，然后将这个消息再用Alice的公钥加密后传给Alice。理论上Alice和Bob都不会发现Eve在偷听他们的消息。今天人们一般用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD" title="公开密钥基础建设">可靠的第三方机构签发证书</a>来防止这样的攻击。</p><h3 id="时间攻击">时间攻击</h3><p>1995年，丹·博内和大卫·布鲁姆利提出了一种出人意料的攻击方式：假如Eve（窃密者）对Alice的硬件有充分的了解，而且知道它对一些特定的消息加密时所需要的时间的话，那么她可以很快地推导出_d_。这种攻击方式之所以会成立，主要是因为在进行加密时所进行的模指数运算是一个比特一个比特进行的，而比特为1所花的运算比比特为0的运算要多很多，因此若能得到多组消息与其加密时间，就会有机会可以反推出私钥的内容。</p><h1 id="pnpnp-complete和np-hard问题">P、NP、NP-Complete和NP-Hard问题</h1><p><strong>P问题</strong>：能在多项式时间内解决的问题 (P：polynominal，多项式)（例如，<strong>计算1-1000的连续整数之和</strong>）</p><p><strong>NP问题</strong>：指一个复杂问题不能确定是否在多项式时间内找到答案，但是可以在多项式时间内验证答案是否正确。 即能在多项式时间内验证得出一个正确解的问题 (NP:Nondeterministic polynominal，非确定性多项式)。（例如，<strong>计算地球上所有原子个数之和</strong>：这个问题就很困难甚至无解，但是现在有个答案是300个，显然是错的，所以很容易验证但不容易求解）</p><p><strong>P问题与NP问题的关系</strong>：<span class="math inline">\(P\subseteq NP\)</span></p><p><strong>NP-Complete问题（NPC）</strong>：这个问题满足两个条件</p><ul><li><p>它是一个NP问题</p></li><li><p>其他所有属于NP的问题都可以归约成它</p></li></ul><p>也就是说，只要解决了这个问题，那么所有的NP问题都能解决。</p><p><strong>归约</strong>：将一个问题转化为另一个问题，使用第二个问题的解来解决第一个问题。</p><p>归约的传递性：如果问题A可约化为问题B，问题B可约化为问题C，那么问题A一定可约化为问题C。</p><p><strong>NP-Hard问题</strong>：它满足NPC问题定义的第二条但不一定要满足第一条。 即所有的NP问题都能约化到它，但是他不一定是一个NP问题。</p><p><strong>NPC与NP-Hard的典型示例-旅行推销员问题</strong></p><p><strong>旅行推销员问题（Traveling Salesman Problem, TSP）</strong> 是一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。</p><p>旅行商问题有两个版本：</p><ol type="1"><li><p>在一个图里，除了起始点以外不重复地遍历所有节点构成一条闭合回路，问这条回路的最短路径是多少？（应如何选择行进路线，以使总的行程最短）---<strong>这个是最优解问题</strong></p></li><li><p>在一个图里，除了起始点以外不重复地遍历所有节点构成一条闭合回路，问路径长度小于等于某个值的这样的回路是否存在？（应如何选择行进路线，以使总的行程小于等于某个值）---<strong>这个是判定性问题</strong></p></li></ol><p>对于<strong>问题1</strong>，是无法令确定型图灵机在多项式时间内验证答案的，所以问题1不是NP问题，因此也不是NPC问题，但是Hamilton回路问题可以约化为TSP问题，而Hamilton回路问题是NP问题，因此是NP-Hard问题。</p><p>对于<strong>问题2</strong>，可以令确定型图灵机在多项式时间内验证答案，所以问题2是NP问题，同时Hamilton回路问题可以约化为TSP问题，而Hamilton回路问题是NP问题，因此问题2是NP-Hard问题，同时它也是NPC问题。</p><p><strong>四者之间的联系</strong>：</p><figure><img src="https://pic1.zhimg.com/80/v2-a7c4f22e07699cbeda418d48379aa4c8_720w.webp" alt="v2-a7c4f22e07699cbeda418d48379aa4c8_720w"><figcaption aria-hidden="true">v2-a7c4f22e07699cbeda418d48379aa4c8_720w</figcaption></figure><p><strong>说明</strong>：</p><ol type="1"><li><p>P问题属于NP问题，NPC问题属于NP问题。</p></li><li><p>P问题属于NP问题，NPC问题属于NP问题。</p></li></ol><p><strong>PS:</strong> 尚未有人能提出证明，说明NPC问题是否能在多项式时间中解决，使得此问题成为著名的数学中未解决的问题。位于剑桥市的<strong>克雷数学研究所</strong>(Clay Mathematics Institute，简称CMI)提供了一百万美金奖金给任何可以证明P=NP或P≠NP的人。</p><div class="tags"><a href="/tags/%E6%A0%87%E6%A0%87%E5%A4%87%E5%BF%98%E5%BD%95/" rel="tag"><i class="ic i-tag"></i> 标标备忘录</a> <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="ic i-tag"></i> 算法</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-07-27 11:20:05" itemprop="dateModified" datetime="2024-07-27T11:20:05+08:00">2024-07-27</time> </span><span id="2024/06/10/post/biao/shor/Shor algorithm/" class="item leancloud_visitors" data-flag-title="Shor算法详解" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>ZoroJan <i class="ic i-at"><em>@</em></i>CYX</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/06/10/post/biao/shor/Shor%20algorithm/" title="Shor算法详解">http://example.com/2024/06/10/post/biao/shor/Shor algorithm/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/06/09/post/springboot/01-java%E6%B5%81-Stream/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;1.png" title="01-Java流-Stream"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 后端</span><h3>01-Java流-Stream</h3></a></div><div class="item right"><a href="/2024/06/10/post/biao/cryptology/Elliptic%20Curve/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;7.png" title="密码学中的椭圆曲线（一）——代数曲线"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 密码学中的椭圆曲线</span><h3>密码学中的椭圆曲线（一）——代数曲线</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#shor%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Shor算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98%E5%88%B0%E6%A8%A1n%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">「因数分解」问题到「模n周期」问题的转化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">RSA加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">1.操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E4%B8%8E%E7%A7%81%E9%92%A5%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">公钥与私钥的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.2.</span> <span class="toc-text">加密信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">解密信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.4.</span> <span class="toc-text">签名信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-number">2.1.5.</span> <span class="toc-text">正确性证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%E8%A7%A3%E5%AF%86%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.6.</span> <span class="toc-text">证明解密逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.1.7.</span> <span class="toc-text">安全性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">2.2.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">密钥生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D"><span class="toc-number">2.2.2.</span> <span class="toc-text">密钥分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%94%BB%E5%87%BB"><span class="toc-number">2.2.3.</span> <span class="toc-text">时间攻击</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pnpnp-complete%E5%92%8Cnp-hard%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">P、NP、NP-Complete和NP-Hard问题</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/06/10/post/biao/shor/Shor%20algorithm/" rel="bookmark" title="Shor算法详解">Shor算法详解</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="ZoroJan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">ZoroJan</p><div class="description" itemprop="description">我的个人博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">38</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">25</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0k4Wm9ybzhJ" title="https:&#x2F;&#x2F;github.com&#x2F;I8Zoro8I"><i class="ic i-github"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMTc5NDkxNDQ4P3NwbV9pZF9mcm9tPTMzMy4xMDA3LjAuMA==" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;179491448?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTEzMDk4Mzg3OTU=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1309838795"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNjMzOTY2OTQ3Mg==" title="https:&#x2F;&#x2F;weibo.com&#x2F;6339669472"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="bWFpbHRvOm0xNTg2MDg2MDM4NkAxNjMuY29t" title="mailto:m15860860386@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链环</a><ul class="submenu"><li class="item"><a href="/site/" rel="section"><i class="ic i-star"></i>网站</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/06/09/post/springboot/01-java%E6%B5%81-Stream/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/06/10/post/biao/cryptology/Elliptic%20Curve/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/job/" title="分类于 工作日志">工作日志</a></div><span><a href="/2024/07/01/post/job/05-%E6%B7%B1%E8%83%BD%E5%BC%80%E5%8F%91%E4%BB%BB%E5%8A%A1%E5%B0%8F%E8%AE%B0/" title="05-深能开发任务小记">05-深能开发任务小记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2024/08/27/post/golang/10-Gin-%E4%B8%AD%E9%97%B4%E4%BB%B6/" title="10-Gin-中间件">10-Gin-中间件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2024/08/20/post/golang/01-Go%E6%8C%87%E5%8D%97/" title="1-Go指南">1-Go指南</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2024/08/22/post/golang/4-Go%E6%8C%87%E5%8D%97-%E5%B9%B6%E5%8F%91/" title="4-Go指南-并发">4-Go指南-并发</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/biao/" title="分类于 标标备忘录">标标备忘录</a> <i class="ic i-angle-right"></i> <a href="/categories/biao/cryptology/" title="分类于 密码学中的椭圆曲线">密码学中的椭圆曲线</a></div><span><a href="/2024/06/10/post/biao/cryptology/Elliptic%20Curve/" title="密码学中的椭圆曲线（一）——代数曲线">密码学中的椭圆曲线（一）——代数曲线</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/utils/" title="分类于 实用小工具">实用小工具</a></div><span><a href="/2024/08/15/post/utils/JRebel%20%E4%BD%BF%E7%94%A8debug%E7%BC%96%E8%AF%91%E5%8D%A1%E4%BD%8F%E9%97%AE%E9%A2%98/" title="实用小工具">实用小工具</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/sql/" title="分类于 数据库">数据库</a></div><span><a href="/2024/07/16/post/sql/02-%E6%97%B6%E9%97%B4%E5%88%A4%E6%96%AD%E6%9F%A5%E8%AF%A2/" title="PostgreSQL中筛选月份和年份查询数据集">PostgreSQL中筛选月份和年份查询数据集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2024/08/27/post/golang/8-Gin-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" title="8-Gin-文件传输">8-Gin-文件传输</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/job/" title="分类于 工作日志">工作日志</a></div><span><a href="/2024/06/27/post/job/03-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" title="03-实现图片压缩">03-实现图片压缩</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/utils/" title="分类于 实用小工具">实用小工具</a></div><span><a href="/2024/06/28/post/utils/utils/" title="实用小工具">实用小工具</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">ZoroJan @ ZoroJan-个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">262k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:58</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/06/10/post/biao/shor/Shor algorithm/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->